### 利用redis和mq的高并发，高可用处理

#### 一、前端处理

一般对于一些秒杀业务我们都会单独制作一个页面，为了确保页面在高峰期不对后端造成太大的消耗我们可以将前端页面进行动静结合的方式，像一些商品的名称，等等不需要变化的我们考虑作为静态数据，利用cdn部署到各地的服务器，确保响应及时

#### 二、后端

##### 对于大量并发的请求我们一般会利用redis+lua脚本+mq的方式来确保高并发的同时也可以保证高可用。

1.在前端的请求到来的时候我们先在redis层面进行数据库的判断，比如用户是否购买过，库存够不够。在符合条件的情况下我们可以继续在redis层面进行库存的扣减以及用户信息的保存

```lua
-- seckill.lua
local voucherId = ARGV[1]
local userId = ARGV[2]
local limit = tonumber(ARGV[3])

local stockKey = 'seckill:stock:' .. voucherId
local orderKey = 'seckill:order:' .. voucherId

-- 1. 检查库存是否充足
local stock = tonumber(redis.call('GET', stockKey))
if stock == nil or stock <= 0 then
    return 1 -- 库存不足
end

-- 2. 获取用户已购买数量
local bought = tonumber(redis.call('HGET', orderKey, userId))
if bought == nil then
    bought = 0
end

-- 3. 检查是否超过限购
if bought >= limit then
    return 2 -- 超过个人限购
end

-- 4. 扣减库存并更新购买记录
redis.call('DECRBY', stockKey, 1)
redis.call('HSET', orderKey, userId, bought + 1)

return 0 -- 成功
```

2.当redis层面验证用户此时有购买的资格后，我们可以直接给前端返回成功的消息，这样的好处就是用户体验感佳，响应快。但是我们要注意，因为数据库的操作是消息中间件异步执行的，所以我们要在前端加一点操作，比如“正在出库中请等待”，不能让用户立刻去查询订单。

3.在mq处理数据库数据的时候我们要保证消息不会被丢失和重复消费，我们这时候就要启用生产者ack确认机制，队列持久化。这里我建议使用手动确认，在业务逻辑处理完调用channel.basicAck()，防止消费者消费时发生宕机造成消息丢失。同时我们还要进行幂等操作，一般是给消息设置唯一id，在业务逻辑上进行幂等判断。

4.如果数据库消费失败，我们要对redis进行回滚操作，这里也要保证原子性，同样利用redis+lua脚本

```lua
-- recover_stock.lua
local voucherId = ARGV[1]
local userId = ARGV[2]

local stockKey = 'seckill:stock:' .. voucherId
local orderKey = 'seckill:order:' .. voucherId

-- 1. 增加库存
redis.call('INCRBY', stockKey, 1)

-- 2. 减少用户购买记录
local bought = tonumber(redis.call('HGET', orderKey, userId))
if bought and bought > 0 then
    redis.call('HSET', orderKey, userId, bought - 1)
end

return 0 -- 成功
```

#### 三、定时任务处理数据

1.在秒杀结束后，我们考虑缓存数据和数据库的更新，因为时间是固定规律比如开始结束时间都是在原来基础上加1，库存恢复到最大库存，考虑使用定时任务来处理

```java
 /**
     * 每天晚上12点把所有优惠劵的开始时间和结束时间加一天，并且将库存恢复
     */
    @Scheduled(cron = "0 0 0 * * ?")
//    @Scheduled(cron = "0 * * * * ?")
    public void updateCouponTime() {
        log.info("更新优惠劵时间");
        LambdaQueryWrapper<Coupons> queryWrapper = new LambdaQueryWrapper<>();
        List<Coupons> couponsList = couponsMapper.selectList(queryWrapper);
        if (couponsList != null && !couponsList.isEmpty()) {
            for (Coupons coupons : couponsList) {
                coupons.setStartTime(coupons.getStartTime().plusDays(1));
                coupons.setEndTime(coupons.getEndTime().plusDays(1));
                coupons.setUpdateTime(LocalDateTime.now());
                coupons.setStock(coupons.getTotalStock());
                stringRedisTemplate.opsForValue().set("seckill:stock:" + coupons.getId(), coupons.getStock().toString());
                couponsMapper.updateById(coupons);
            }
        }
    }
```

2.上面的操作可以避免雪崩和击穿的情况，因为热点的数据不会过期，但是解决不了穿透的问题，穿透redis老生常谈的话题了，返回空值，布隆过滤器都能解决

#### 四、改进方向

#### 1. 前端优化补充： polling vs websocket

*   **现状**：您提到返回成功消息后，前端显示“正在出库中请等待”。
*   **优化建议**：此时前端需要一个机制来获取最终的异步处理结果。
    *   **方案A（简单）**：**轮询 (Polling)**。前端每隔几秒调用一个“查询订单状态”的接口，直到查询成功或超时。
    *   **方案B（高效）**：**WebSocket**。在用户秒杀成功后，建立WebSocket连接。当后端MQ消费者处理完订单后，通过WebServer推送一条成功消息给前端。这比轮询更实时、效率更高。

#### 2. 后端细节深化

**a) Redis 数据结构和Key设计**

*   **用户购买记录**：您使用 `HSET` 存储用户购买记录，Key为 `seckill:order:{voucherId}`，Field是用户ID，Value是数量。
    *   **优点**：方便用 `HGET` 快速查询单个用户的购买情况。
    *   **潜在问题**：如果参与用户量极大（百万级），这个Hash会非常大，可能带来Redis内存和性能问题。
    *   **替代方案**：可以考虑为每个优惠券单独用一个Set来存储用户ID `SADD seckill:order:users:{voucherId} {userId}`。检查用户是否购买过用 `SISMEMBER`，同样很快，且更节省内存（取决于用户数量）。但限购次数如果不是1次，此方案不适用。

**b) MQ 选型与死信队列**

*   **重试策略**：手动ACK时，如果消费失败，不要直接 `basicNack` 并 `requeue=true`，这会导致消息立即重入队列，可能引起恶性循环。
*   **最佳实践**：配置**死信队列 (DLX)**。消费失败时，`basicNack` 并 `requeue=false`，让消息进入死信队列。然后对死信队列的消息设置延迟时间后再次投递，实现**延迟重试**。例如：5s后重试 -> 10s后重试 -> 30s后重试，重试3次后若还失败，则转入“最终失败队列”报警人工处理。

**c) 数据库幂等性的具体实现**

*   **唯一索引**：订单表上应该建立 `(user_id, voucher_id)` 的联合唯一索引。这是防止重复下单最坚固的防线，即使消息重复消费，数据库插入也会失败。
*   **状态机**：订单状态的设计（如：0-生成中，1-已生成，2-无效）。更新状态时带上前置状态校验 `UPDATE order SET status = 1 WHERE id = 100 AND status = 0`，这也是幂等的。

#### 3. 关于缓存穿透

您说的完全正确，布隆过滤器或缓存空值可以有效解决穿透。在您的架构中，可以在Lua脚本的第一行之前加一个检查：如果 `voucherId` 根本不是一个有效的活动ID（比如查不到），可以直接返回一个特定错误码。这个“有效活动ID列表”可以提前预热到Redis的Set中，或者在Lua脚本里直接判断 `stockKey` 是否存在。
